<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>MuhDzulfiqar</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    

  <!-- navbar -->
  <nav class="navbar navbar-inverse .bg-secondary navbar-fixed-bottom">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target ="#bs-example-navbar-collapse-1" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a href="https://www.instagram.com/muhammad.dzulfiqarr/" class="navbar-brand page-scroll">MUH. DZULFIQAR</a>
      </div>

    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#tugas1" class="page-scroll">Tugas 1</a></li>
        <li><a href="#tugas2" class="page-scroll">Tugas 2</a></li>
        <li><a href="#tugas3" class="page-scroll">Tugas 3</a></li>
        <li><a href="#tugas4" class="page-scroll">Tugas 4</a></li>
        <li><a href="#tugas5" class="page-scroll">Tugas 5</a></li>
        <li><a href="#tugas6" class="page-scroll">Tugas 6</a></li>
        <li><a href="#tugas7" class="page-scroll">Tugas 7</a></li>
        <!-- <li><a href="">About3</a></li> -->
      </ul>
    </div>
    </div>
  </nav>
  <!-- akhir navbar -->



    <!-- Jumbotron -->
    <div class="jumbotron text-center">
    <img src="img/foto.jpeg" class="img-circle">
    <h1>Muh. Dzulfiqar Website</h1>
    <p>D121181510</p>
    </div>
    <!-- Akhir Jumbotron -->

    <!-- tugas 1 -->
    <section class="about" id="tugas1">
    <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">TBO mempelajari mengenai</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri">&nbsp; &nbsp; &nbsp; Komputasi merupakan pengetahuan yang sangat penting karena membahas mengenai bagaimana cara pembuatan mesin yang mampu melakukan proses-proses intelektual apapun yang dapat dilakukan secara mekanis oleh manusia dapat dilakukan oleh komputer digital

Teori komputasi telah dimulai sejak rancangan algoritma Euclid dan penggunaan kompleksitas aksomatik oleh bangsa Babilonia. kepentingan teori komputasi saat ini dibentuk oleh kelahiran komputer digital yang mampu melakukan jutaan operasi per detik serta kehendak formalisasi konsep produser efektif yang berkonsekuensi pada pembuktian fungsi yang tak dapat dikomputasi.

Teori otomata mempelajari model mesin komputer menggunakan model matematika. namun matematika yang digunakan benar-benar berbeda bila dibandingkan dengan matematika klasik dan kallkulus. model yang digunakan adalah model mesain state atau model transisi state. <br>
Terdapat 3 model komputasi yang utama dalam teori otomata yaitu :<br>

1. Finite State Automata  (Contoh : Mesin jaja/ vending machine)<br>

2. Push Down Automata (Contoh : Running text)<br>

3. Turing Machine (Contoh : netbook)<br></p>
        </div>
        <div class="col-sm-6">
         <p class="pKanan">Contoh penerapan ilmu TBO :<br>
<img src="img/vending.jpg">
<img src="img/switch.jpg"><br>
Vending machine & Switch On Off</p>
        </div>
            <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">Fungsi Mempelajari TBO</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri"> &nbsp; &nbsp; &nbsp; Pengertian mesin bukan hanya mesin elektronis/mekanis saja melainkan segala sesuatu (termasuk perangkat lunak) yang memenuhi ketiga ciri di atas. Penggunaan automata pada perangkat lunak terutama pada pembuatan kompiler bahasa pemrograman. <br>

&nbsp; &nbsp; &nbsp;Secara garis besar ada dua fungsi automata dalam hubungannya dengan bahasa, yaitu : <br>
- Fungsi automata sebagai pengenal (RECOGNIZER) string-string dari suatu
bahasa, dalam hal ini bahasa sebagai masukan dari automata <br>
- Fungsi automata sebagai pembangkit (GENERATOR) string-string dari suatu bahasa, dalam hal ini bahasa sebagai keluaran dari automata</p>
        </div>
        <div class="col-sm-6">
         <p class="pKanan"> &nbsp; &nbsp; &nbsp;Untuk mengenali string-string dari suatu bahasa, akan dimodelkan sebuah automaton
yang memiliki komponen sebagai berikut : <br>
- Pita masukan, yang menyimpan string masukan yang akan dikenali; <br>
- Kepala pita (tape head), untuk membaca/menulis ke pita masukan; <br>
- Finite State Controller (FSC), yang berisi status-status dan aturan-aturan yang
mengatur langkah yang dilakukan oleh automaton berdasarkan status setiap saat
dan simbol masukan yang sedang dibaca oleh kepala pita; <br>
- Pengingat (memory), untuk tempat penyimpanan dan pemrosesan sementara
Automaton pengenal, setelah membaca string masukan dan melakukan langkahlangkah
pemrosesan yang diperlukan, akan mengeluarkan keputusan apakah
string tersebut dikenali atau tidak.</p>
        </div>
      </div>
    </div> 
      </div>
    </div> 
    </section>
    <!-- akhir tugas1 -->

      <!-- tugas2 -->
    <section class="about" id="tugas2">
    <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">Notasi Big O</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri"> &nbsp; &nbsp; &nbsp; Big O Notation adalah cara untuk mengkonversi keseluruhan langkah-langkah suatu algoritma kedalam bentuk Aljabar, yaitu dengan menghiraukan konstanta yang lebih kecil dan koefisien yang tidak berdampak besar terhadap keseluruhan kompleksitas permasalahan yang diselesaikan oleh algoritma tersebut. Big O notation juga bisa melalukan analisa terhadap sebuah algoritma pemograman terhadap waktu ekskusi. Tentang seberapa efisien dan kompleksitas barisan kode dalam dimensi waktu.   Algoritma kadang melakukan jumlah operasi yang sama pada setiap kali pemanggilannya yang ternyata memerlukan waktu yang konstan. Selain itu ada juga algoritma lain yang melakukan jumlah operasi yang berbeda, tergantung dari jumlah input pada parameter seperti pemanggilan berurutan (sequence), maka dapat dipahami bahwa jumlah operasi yang dilakukannya tergantung dari jumlah pemanggilan. Dan disini harus memperhitungkan parameter yang nilainya mempengaruhi jumlah operasi yang dilakukan (problem size, kadang juga disebut input size)<br> <br>
          	Contoh :

          <img src="img/contoh1.jpg"></p>
        </div>
        <div class="col-sm-6">
          <p class="pKanan">&nbsp; &nbsp; &nbsp; Fungsi Notasi Big O : <br>
          Notasi Big-O berguna untuk membandingkan beberapa algoritma dari untuk persoalan yang sama untuk menentukan yang terbaik. <br> <br>
          &nbsp; &nbsp; &nbsp; Agar function berjalan dengan waktu yang cepat (time complexity) dan efisien secara memory (space complexity). Ada beberapa Notasi yang membantu kita menghitung Big O Notation Time dan Space Complexity yaitu: <br>

		1. Constant, f(n)=1 <br>
		2. Linear, f(n)=n <br>
		3. Quadratic, f(n)=n² <br>
		4. Logarithmic, f(n)=log n = <br> <br>

		&nbsp; &nbsp; &nbsp; Kegunaan dari Notasi Big-O dilakukan untuk mengamati sifat/kecenderungan suatu fungsi untuk masukan (input) yang sangat besar/sangat kecil dengan cara yang simpel namun teliti sehingga dapat dilakukan perbandingan dengan fungsi-fungsi yang lain Lebih jauh lagi, simbol O digunakan untuk mengambarkan sebuah batas atas dari asimptotik suatu jarak/ukuran dari sebuah fungsi untuk fungsi yang lebih simpel. Terdapat juga simbol-simbol seperti o, O,?, dan T untuk batas-batas atas, bawah, dan rata-rata.

  Aplikasinya terdapat pada dua area: dalam matematika, notasi ini digunakan untuk mengetahui karakteristik dari syarat sisa untuk wilayah tak-hingga yang terpotong, terutama seri asimptotik. Dalam computer science,notasi ini digunakan untuk menganalisa kompleksitas dari suatu algoritma. Biasanya, notasi O besar digunakan untuk menggambarkan batas-batas asimptotik. <br>

		
<img src="img/bigO.png"></p>
        </div>
      </div>
    </div> 
    </section>
    <!-- akhir tugas2 -->

    <!-- tugas3 -->
    <section class="about" id="tugas3">
    <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">Finite Automata</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri"> &nbsp; &nbsp; &nbsp; Automata merupakan suatu sistem yang terdiri atas sejumlah berhingga state, di mana state menyatakan informasi mengenai input. Automata juga dianggap sebagai mesin otomatis (bukan mesin fisik) yang merupakan suatu model matematika dari suatu sistem yang menerima input dan menghasilkan output, serta terdiri dari sejumlah berhingga state <br> <br>  
&nbsp; &nbsp; &nbsp;Finite State Automata (FSA) atau finite automata adalah mesin automata dari bahasa regular. finite automata merupakan model matematika yang dapat menerima input dan mengeluarkan output yang memiliki state yang berhingga banyaknya dan dapat berpindah dari satu state ke state lainnya berdasarkan input dan fungsi transisi.
 <br> 
&nbsp; &nbsp; &nbsp;Secara formal finite state automata dinyatakan oleh 5 tupel atau M=(Q, Σ, δ, S, F), di mana :
Q = himpunan hingga state <br>  
Σ = himpunan hingga simbol input / alfabet <br> 
δ = fungsi transisi, menggambarkan simbolinput. fungsi transisi biasanya diberikan dalam bentuk tabel. <br> 
S = state awal / kedudukan awal (initial state) <br>  
F = himpunan state akhir. <br> <br> 
Ada 2 jenis FSA yaitu DFA dan NFA, yang dimana : <br> 
Deterministic finite automata (DFA). pada DFA transisi state FSA akibat pembacaan sebuah simbol bersifat tertentu.
δ : Q X Σ --> Q <br>
Sedangkan NFA adalah singkatan dari non-deterministic finite automata. pada NFA transisi state FSA akibat pembacaan sebuah simbol bersifat tak tentu.
δ : Q X Σ --> 2Q <br> <br>  
&nbsp; &nbsp; &nbsp;Mudah untuk membuat NFA daripada DFA untuk bahasa reguler tertentu. Automata terbatas disebut NFA ketika terdapat banyak jalur untuk input spesifik dari status saat ini ke status berikutnya. Setiap NFA bukanlah DFA, tetapi setiap NFA dapat diterjemahkan ke dalam DFA. NFA didefinisikan dengan cara yang sama seperti DFA tetapi dengan dua pengecualian berikut, NFA berisi beberapa status berikutnya, dan berisi transisi ε. Contoh penerapan NFA seperti pada Aplikasi Simulasi Mesin Kopi Vending, ATM, aplikasi pengisian Kartu Rencana Studi (KRS). <br>
<img src="img/tugas3(1).jpg"><br>
        </div>
        <div class="col-sm-6">
          <p class="pKanan"><strong> Pemanfaatan NFA dalam pengisian krs :  </strong><br> <br>
&nbsp; &nbsp; &nbsp; Pada paper ini membahas tentang bagaimana metode Finite State Automata jenis NFA dapat diimplementasikan dalam mengisi kartu rencana studi (KRS). <br> <br>

&nbsp; &nbsp; &nbsp;Tuple M pada FSA jenis NFA diantaranya (Q, Ʃ, δ, S, F) yang mengartikan untuk Q=himpunan state, Ʃ=himpunan input, δ=fungsi transis, S=state awal, F=state akhir sebagai contoh sederhana dengan NFA[4]. Dari diagram dibawah, kita bisa melihat bahwa tuple-nya sebagai berikut: <br>
Q = {q1,q2,q3,q4} <br>
Ʃ = {0,1}<br>
δ = Fungsi transisi <br>
δ(q1,0)=q2, δ(q1,1)=q2, δ(q2,0)=q2, <br>
δ (q2,1)=(q3,q4), δ(q3,0)=q3, δ(q3,1)=q4, <br>
δ (q4,0)=q4, δ(q4,1)=q4 <br>
S = {q1}<br>
F = {q4} <br> <br>

dalam pengisian tersebut maka tabel transisinya yaitu: <br> <br>
<img src="img/tugas3(2).png"><br> <br>
&nbsp; &nbsp; &nbsp;Kasus pada Tabel 1 dapat diterapkan kedalam pengisian KRS, sebagai contoh bila q1 itu adalah mata kuliah Algoritma Pemograman dan q2 adalah Bahasa dan Automata, dan himpunan input 0 sebagai di tidak ambil dan himpunan input 1 sebagai ambil, maka untuk bisa mengambil mata kuliah Bahasa dan Autama harus mengambil mata kuliah Algoritma Pemograman (q1) terlebih dahulu.

sistem dirangcang dengan menggunakan flowchart, yang menjelaskan tentang gambaran umum aplikasi pengisian Kartu Rencana Studi. pada flowchart aplikasi dijelaskan sebagai berikut:
mahasiswa menentukan mata kuliah yang akan diambil semester berikutnya.
sistem akan memfalidasi mata kuliah yang diambil.
sistem akan menampilkan laporan diterimanya atau ditolaknya pengisian KRS tersebut.

    </p> 
        </div>
      </div>
    </div> 
    </section>
    <!-- akhir tugas3 -->

     <!-- tugas4 -->
    <section class="about" id="tugas4">
    <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">Regular Expression (RegEx)</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri"> &nbsp; &nbsp; &nbsp; Konsep tentang regex pertamakali muncul di tahun 1951, ketika seorang ilmuan matematikan bernama Stephen Cole Kleene memformulasikan definisi tentang bahasa formal.1 emudian konsep ini diadopsi di beberapa program dan menjadi umum digunakan pada program pemeroses teks seperti sed, awk, grep, dll. <br> <br>

&nbsp; &nbsp; &nbsp;Regex adalah singkatan dari Regular Expresion. Regex merupakan sebuah teks (string) yang mendefinisikan sebuah pola pencarian sehingga dapat membantu kita untuk melakukan matching (pencocokan), locate (pencarian), dan manipulasi teks. <br> <br>

&nbsp; &nbsp; &nbsp;Bahasa disebut reguler jika terdapat FSA yang dapat menerimanya. Salah satu cara mendeskripsikan bahasa reguler adalah melalui notasi bahasa regular ekspresi. Notasi ini melibatkan kombinasi string symbol dari beberapa alfabet Σ, tanda kurung, dan operator +, ·, *.
<br> <br>
<strong>Definisi Formal dari Ekspresi Reguler</strong>
<br>
&nbsp; &nbsp; &nbsp;Ekspresi regular dibangun dari konstituen primitif dengan berulang kali menerapkan aturan rekursif tertentu. Ini mirip dengan cara membangun familiar arithmetic expressions.
<br> <br>
&nbsp; &nbsp; &nbsp;Misalkan Σ adalah alfabet tertentu. Kemudian: <br>
1. ∅, λ, dan a ∈ Σ adalah ekspresi reguler. Ini disebut primitif ekspresi reguler. <br>
2. Jika r1 dan r2 adalah ekspresi reguler, jadi r1 + r2, r1 · r2, r ∗1, dan (r1). <br>
3. String adalah ekspresi reguler jika dan hanya jika dapat diturunkan dari ekspresi reguler primitif oleh sejumlah aplikasi yang terbatas dari aturan didalamnya. <br> <br>

        </div>
        <div class="col-sm-6">
          <p class="pKanan">&nbsp; &nbsp; &nbsp;Jadi,ekspresi reguler berfungsi sebagai bahasa masukan untuk banyak sistem yang memproses string. Contohnya termasuk: <br> <br>
1. Cari perintah seperti UNIX grep atau perintah yang setara untuk mencari string yang dilihat seseorang di browser Web atau sistem format teks, seperti pada fitur spell-checker yang tersedia pada Microsoft Word dimana dapat membantu memberikan penanda untuk kata-kata yang salah ketik, atau tidak sesuai format. Sistem ini menggunakan notasi seperti ekspresi reguler untuk mendeskripsikan pola yang ingin ditemukan pengguna didalam file. Sistem pencarian yang berbeda dikonversi ekspresi reguler menjadi DFA atau NFA, dan simulasikan robot akan mencari. <br> <br>
2. Generator penganalisis leksikal, seperti Lex atau Flex. Ingatlah bahwa leksikal analyzer adalah komponen kompilator yang merusak program sumber menjadi unit logis (disebut token) dari satu atau lebih karakter yang memiliki file significant yang sama. Contoh token termasuk kata kunci (mis., Sementara), identifikasi (misalnya, huruf apa pun yang diikuti dengan nol atau lebih huruf dan / atau angka), dan tanda, seperti + atau <=. Generator penganalisis leksikal menerima deskripsi bentuk token, yang pada dasarnya adalah ekspresi reguler, dan menghasilkan DFA yang mengenali token mana yang muncul berikutnya.
    </p> 
        </div>
      </div>
    </div> 
    </section>
    <!-- akhir tugas4 -->

     <!-- tugas5 -->
    <section class="about" id="tugas5">
    <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">Context Free Grammar</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri"> &nbsp; &nbsp; &nbsp; Context Free Grammar adalah tata bahasa formal di mana setiap aturan produksi adalah dalam bentuk A → B di mana A adalah pemproduksi, dan B adalah hasil produksi. Batasannya hanyalah ruas kiri adalah sebuah simbol variabel. Dan pada ruas kanan bisa berupa terminal, symbol, variable ataupun ɛ, Contoh aturan produksi yang termasuk CFG adalah seperti berikut ini: <br> <br>

• X  → bY | Za<br>
• Y  → aY | b<br>
• Z  → bZ | Ɛ<br><br>


&nbsp; &nbsp; &nbsp;CFG adalah tata bahasa yang mempunyai tujuan sama seperti halnya tata bahasa regular yaitu merupakan suatu cara untuk menunjukkan bagaimana menghasilkan suatu untai-untai dalam sebuah bahasa. <br> <br>


&nbsp; &nbsp; &nbsp;CFG perlu disederhankan dengan tujuan untuk melakukan pembatasan sehingga tidak menghasilkan pohon penurunan yang memiliki kerumitan yang tak perlu atau aturan produksi tak berarti. Berikut merupakan langkah-langkah dalam melakukan penyederhanaan CFG: <br>

1. Eliminasi ɛ-production <br>

2. Eliminasi unit production <br>

3. Eliminasi useless symbol <br> <br>

        </div>
        <div class="col-sm-6">
          <p class="pKanan"> <strong>Pemanfaaatan Context Free Grammar : </strong> <br> <br>
            &nbsp; &nbsp; &nbsp;CFG digunakan untuk melakukan penelusuran sebuah kalimat (sentensial) . Penelusuran sentensial dilakukan dengan melakukan analisis sintaks, yaitu melakukan penelusuran sentensial sampai pada simbol awal grammar.  Analisis sintaks dapat dilakukan melalui Derivasi dan Parsing. <br> <br>


&nbsp; &nbsp; &nbsp;Contoh kasus: Analisis sintaks. Problem: Lakukanlah analisis sintaks untuk kalimat x23b menggunakan kedua cara penelusuran sentensial derivasi dan parsing jika diketahui G = {I → H | IH | IA, H → a | b | c | ... | z, A → 0 | 1 | 2 | ... | 9} <br> <br>

&nbsp; &nbsp; &nbsp;Selain itu bisa juga digunakan untuk memeriksa ketepatan tata bahasa kalimat. Aturan dapat Diterapkan secara terbalik untuk memeriksa apakah sebuah string secara tata bahasa benar sesuai dengan tata bahasa.


CFG juga digunakan untuk mendeskripsikan bahasa pemrograman dan program pengurai dalam kompiler dapat dihasilkan secara otomatis dari tata bahasa bebas konteks.
    </p> 
        </div>
      </div>
    </div> 
    </section>
    <!-- akhir tugas5 -->

    <!-- tugas6 -->
    <section class="about" id="tugas6">
    <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">Hierarki Chomsky</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri"> 
            <img src="img/tugas6.png"><br> <br>
            &nbsp; &nbsp; &nbsp; Chomsky adalah salah satu pemrakarsa teori pemerolehan bahasa yang meyakini bahwa proses pemerolehan bahasa adalah suatu proses mental atau sebuah hirarki penahanan kelas tata bahasa formal. Yang digambarkan oleh Noam Chomsky pada tahun 1956. Hal ini juga dinami Marcel-Paul Schutzenberger, yang memainkan peran penting dalam pengembangan teori bahasa formal. Pada dasranya Chomsky Hierarchy ini memungkinkan kemungkinan bagi pemahaman dan penggunaan model ilmu komputer yang memungkinkan programmer untuk mencapai tujuan linguistik bermakna sistematis. <br> <br>

        </div>
        <div class="col-sm-6">
          <p class="pKanan"> 
            &nbsp; &nbsp; &nbsp;Ada 4(empat) kelas pengelompokan suatu bahasa, yang kita kenal dengan “Chomsky Hierarchy”. Hirarki atau tingkatan bahasa ini dikembangkan oleh Noam Chomsky pada tahun 1959. <br> <br>


1. Tipe 0 (Unrestricted)<br>

&nbsp; &nbsp; &nbsp;Pada tipe 0 ini "simbol  ruas sebelah kiri harus minimal ada sebuah simbol variabel dan tidak ada batasan pada aturan produksi". Tipe 0 menggunakan mesin automata dengan Mesin Turing.
<br> <br>

2. Tipe 1 (Context Sensitive)<br>

&nbsp; &nbsp; &nbsp;Pada tipe 1 ini "simbol pada ruas sebelah kiri harus minimal ada sebuah variabel dan panjang String ruas kiri harus lebih kecil atau sama dengan ruas kanan (|a| <=|B|)". Tipe 1 menggunakan mesin automata dengan Linier Bounded Automata.
<br> <br>

3. Tipe 2 (Context Free / Bebas Konteks)<br>

&nbsp; &nbsp; &nbsp;Pada tipe 2 ini "simbol sebelah kiri harus simbol variabel". Tipe 2 menggunakan mesin automata dengan Push Down Automata.
<br><br>

4. Tipe 3 (Regular)<br>

&nbsp; &nbsp; &nbsp;Pada tipe 3 ini "simbol sebelah kiri harus berupa simbol variabel dan simbol sebelah kanan maksimal hanya memiliki sebuah simbol variabel dan bila ada terletak di paling kanan". Tipe 3 menggunakan mesin automata dengan Finite State Automata DFA dan NFA.



    </p> 
        </div>
      </div>
    </div> 
    </section>
    <!-- akhir tugas6 -->

 <!-- tugas7 -->
    <section class="about" id="tugas7">
    <div class="container">
      <div class="row">
      <div class="col-sm-12">
        <h2 class="text-center">Mesin Turing</h2>
        <hr>
      </div>
      </div>
      <div class="row">
        <div class="col-sm-6">
          <p class="pKiri"> 
            
            &nbsp; &nbsp; &nbsp; Mesin Turing adalah model komputasi teoritis yang ditemukan oleh Alan Turing, berfungsi sebagai model ideal untuk melakukan perhitungan matematis. Walaupun model ideal ini diperkenalkan sebelum komputer nyata dibangun, model ini tetap diterima kalangan ilmu komputer sebagai model komputer yang sesuai untuk menentukan apakah suatu fungsi dapat selesaikan oleh komputer atau tidak (menentukan computable function). Mesin Turing terkenal dengan ungkapan ” Apapun yang bisa dilakukan oleh Mesin Turing pasti bisa dilakukan oleh komputer.” Mesin Turing sendiri merupakan model yang sangat sederhana dari komputer. Secara esensial, mesin Turing adalah sebuah finite automaton yang miliki sebuah tape tunggal dengan panjang tak terhingga yang dapat membaca dan menulis data. Mesin Turing menggunakan notasi seperti ID-ID pada PDA untuk menyatakan konfigurasi dari komputasinya.

 <br> <br>
<img src="img/tugas7.jpg">
<br> <br>
<strong>Cara Kerja Mesin Turing</strong> <br>

&nbsp; &nbsp; &nbsp; Pada PDA (Push Down Otomata) digunakan stack untuk menyimpan dan mengakses data inputan. Tetapi hal ini menyebabkan kemampuan kerja PDA yang terbatas karena pada prinsip stack,hanya data teratas yang bisa diakses. Ini menyebabkan keterbatasan PDA. Mesin turing menggunakan pita (tape) sebagai memori yang berbentuk array . Hal ini menyebabkan data pada pita dapat diakses dari mana saja.
<br> <br>

<strong>Spesifikasi Mesin Turing</strong> <br>

• Mesin turing memiliki pita berupa array sebagai memori yang dapat menyimpan sebuah &nbsp;&nbsp;simbol tunggal <br>

• Mesin turing memiliki head sebagai penunjuk posisi yang sedang diakses pada pita <br>

• Head dapat bergerak kekanan/kekiri pada pita sesuai fungsi transisi yang ditetapkan &nbsp;&nbsp;untuk membaca inputan <br>

• Head juga dapat melakukan penulisan/ mengubah isi pita <br>

        </div>
        <div class="col-sm-6">
          <p class="pKanan"> 
            Sebuah mesin turing secara formal dinyatakan dalam 7 tupel

M = (Q, S, G, d, S, F, b) <br>

Dimana: <br> 

Q =  himpunan state  <br>

S = himpunan simbol input  <br>

G = simbol pada pita,termasuk blank  <br>

d = fungsi transisi  <br>

S = state awal (S anggota elemen Q)  <br>

F = himpunan state akhir  <br>

b = simbol kosong (menandakan bagian yang tidak terisi)<br> <br>


<strong>Prinsip Kerja mesin Turing</strong> <br>

1. Lihat state semula dan simbol yang ditunjuk head <br>

2. Berdasarkan fungsi transisinya,tentukan: -state berikutnya -Lakukan penulisan ke pita &nbsp; &nbsp;&nbsp; &nbsp;Gerakkan head ke kanan dan ke kiri <br> 

3. Bila dari pasangan state dan simbol yang ditunjuk head tidak ada lagi fungsi <br>&nbsp;&nbsp;&nbsp; &nbsp;transisinya,berarti mesin turing berhenti <br>

4. Bila mesin turing berhenti di dalam state final (F) , berarti input diterima. Sebaliknya &nbsp;&nbsp;&nbsp;&nbsp;jika mesin berhenti tidak pada state akhir,maka berarti inputan tersebut ditolak. <br> <br>


<strong>Contoh Mesin Turing Sederhana</strong> <br>

  &nbsp; &nbsp; &nbsp;Sebuah contoh mesin Turing dapat dibangun untuk melakukan komputasi sederhana yang didefinisikan seperti ini: Tentukan ada berapa angka 1 dalam sebuah string berbentuk 0111...110 (rangkaian angka 1 yang didahului dengan 0 dan diakhiri juga dengan 0), apakah berjumlah genap atau berjumlah ganjil.  Jika angka 1 di antara dua angka 0 berjumlah genap, tulis sebuah angka 0 pada salah satu sel dari tape mesin Turing. Jika angka 1 di antara dua angka 0 berjumlah ganjil, tulis sebuah angka 1 pada salah satu sel dari tape mesin Turing.
<br> <br>

  &nbsp; &nbsp; &nbsp;Untuk menyelesaikan masalah komputasi ini, kita buat tiga buah State bagi mesin Turing ini, yaitu Start, Even, dan Odd. Di samping itu kita buat sekumpulan aturan Transisi yang digunakan oleh mesin Turing ini untuk melakukan proses komputasinya. Aturan-aturan Transisi tersebut dapat dituliskan demikian:
<br> <br>

1. Jika mesin Turing berada pada status Start, dan membaca simbol 0 pada Tape, lakukan hal berikut: Pindah status menjadi status Even, Ganti simbol 0 pada Tape dengan Blank (atau Hapus simbol 0 pada Tape), dan Bergerak ke kanan satu sel. 
<br> <br>
2. Jika mesin Turing berada pada status Even, dan membaca simbol 1 pada Tape, lakukan hal berikut: Pindah status menjadi status Odd, Ganti simbol 1 pada Tape dengan Blank, dan Bergerak ke kanan satu sel. 
<br> <br>
3. Jika mesin Turing berada pada status Odd, dan membaca simbol 1 pada Tape, lakukan hal berikut: Pindah status menjadi Even, Ganti simbol 1 pada Tape dengan Blank, dan Bergerak ke kanan satu sel. 
<br> <br>
4. Jika mesin Turing berada pada status Even, dan membaca simbol 0 pada Tape, lakukan hal berikut: Pindah status menjadi Halt, Ganti simbol 0 pada Tape dengan 0, dan tetap pada sel tersebut (tidak perlu berpindah ke kiri maupun ke kanan).  <br> <br>

5. Jika mesin Turing berada pada status Odd, dan membaca simbol 0 pada Tape, lakukan hal berikut: Pindah status menjadi Halt, Ganti simbol 0 pada Tape dengan 1, dan tetap pada sel tersebut. <br>


    </p> 
        </div>
      </div>
    </div> 
    </section>
    <!-- akhir tugas7 -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="js/jquery-3.5.1.min.js"></script>
    <script src="js/jquery.easing.1.3.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>

    <script src="js/script.js"></script>
  </body>
</html>